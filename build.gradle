apply plugin: 'java'
apply plugin: 'maven'
apply plugin: 'gradlecm'

description = 'Gradle Build CM Plugin'

//
// Normal dev builds will typically get SNAPSHOT versions
//
def buildMajorVersion=1
buildversion {
	doLast {
		//
		// Set the pattern after the tags have been used to set the initial 
		// values.  Release gets the default pattern of the maven default 
		//
		def branchName = buildvcs.getBranchName()
		if (branchName != "release") {
			version.setPattern("%M%.%m%-SNAPSHOT") 
		}
		version.updateMajor(new Integer(buildMajorVersion)) 
		println("Currently working on sources for " + version);
	}
}

//
// Clean up the gradle test area
//
clean {
	doLast {
		project.delete("src/test/gradle/build")
		project.delete("src/test/gradle/gitfiles")
		project.delete("src/test/gradle/.gradle")
		project.delete("src/test/gradle/.git")
	}
}

//
// Manifest specific properties.  This would be done for the War/Ear target if 
// those plugins were also being used.
//
jar {
    manifest {
		doFirst {
			attributes 'Implementation-Title': description, 'Implementation-Version': version
		}
    }
}

//
// Build dependency section
//
repositories {
	mavenCentral()
}

dependencies {
	compile gradleApi()
	compile group: 'org.eclipse.jgit', name: 'org.eclipse.jgit', version: '2.1.0.201209190230-r'
	testCompile group: 'junit', name: 'junit', version: '4.+'
}

//
// Use bootstrap versions of CM plugin 
//
buildscript {
	repositories {
		mavenCentral()
		mavenRepo url: 'http://kercheval.org/mvn-repo/releases'
	}
	dependencies {
		classpath 'org.kercheval:GradleCMPlugin:1.+'
	}
}

//
// The publish group for the repository
//
group = 'org.kercheval'

uploadArchives {
	repositories {
		mavenDeployer {
			//
			// Note this cute little bit of indirection.  The upload target will place the repository 
			// files into a local github repository that is at the same level as the root of this 
			// project.  I have cloned my maven repository into that location so that these line up
			// correctly.  This allows me to validate the release binaries and commit them as a 
			// seperate step.  If I had nexus deployed and was using CI for this project, this repository
			// reference would be pointing directly at that instead.
			//
			repository(url: "file://${rootDir}/../mvn-repo/releases")

			//
			// Note that this repository will be used ONLY if the 
			// version ends with 'SNAPSHOT'.
			//
			snapshotRepository(url: "file://${rootDir}/../mvn-repo/snapshots") 
			pom.project {
				licenses {
					license {
						name 'Creative Commons Attribution 3.0 Unported License'
						url 'http://creativecommons.org/licenses/by/3.0/deed.en_US'
					}
				}
			}
		}
	}
}

